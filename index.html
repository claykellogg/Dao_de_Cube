
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Dao De Cube</title>
	<style>
		body{
			margin: 0px !important;
    		padding: 0px !important;
			overflow: hidden;
		}
	</style>
</head>
<body>
	<script src="three.min.js"></script>
	<script src="Math.js"></script>
	<script src='OrbitControls.js'></script>
	<script>
		// ------------------------------------------------------------ Scene ------------------------------------------------------------
		var scene = new THREE.Scene( );

		var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 3000 );
		var controls = new THREE.OrbitControls( camera );
		camera.position.set( 0, 8, 12 );
		controls.update( );

		var renderer = new THREE.WebGLRenderer( );
		renderer.setClearColor( 0x000000 );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		window.addEventListener( 'resize', function( ) {
			var width = window.innerWidth;
			var height = window.innerHeight;
			renderer.setSize( width, height );
			camera.aspect = width / height;
			camera.updateProjectionMatrix();
		} );

		var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 1.0 );
		scene.add( ambientLight );

		//var pointLight = new THREE.PointLight( 0xFFFFFF, 0.5 );
		//pointLight.position.set( 0, 20, 20 );
		//scene.add( pointLight );
		
		function render( ) {
			requestAnimationFrame( render );
			renderer.render( scene, camera );
		}
		render( );
		// ------------------------------------------------------------ End Scene ------------------------------------------------------------
		
		// ------------------------------------------------------------ Objects ------------------------------------------------------------
		
		var cubieSize = 1;
		colors = { 
			'white':0xFFFFFF, 'yellow':0xFFFF00, 'red':0xFF0000, 'orange':0xFFA000, 
			'blue':0x0000FF, 'green':0x00FF00, 'gray':0x505050
		};
		colorScheme = { 'R':'red', 'L':'orange', 'U':'yellow', 'D':'white', 'F':'blue', 'B':'green' };
		
		var keys = [
			'LUF', 'UF', 'RUF', 'LU', 'U', 'RU', 'LUB', 'UB', 'RUB',
			'LF', 'F', 'RF', 'L', 'C', 'R', 'LB', 'B', 'RB', 
			'LDF', 'DF', 'RDF', 'LD', 'D', 'RD', 'LDB', 'DB', 'RDB' 
		]
		
		function getCubieColorScheme( key ) {
			var cubieColorScheme = { 'R':'gray', 'L':'gray', 'U':'gray', 'D':'gray', 'F':'gray', 'B':'gray' };  // Default face color is gray until properly computed.
			if ( key == 'C' ) {
				return cubieColorScheme;  // Center cubie is the only default colored cubie.
			}
			for (var index in key ) {
				cubieColorScheme[key[index]] = colorScheme[key[index]];
			}
			return cubieColorScheme;
		}
		
		function getCubieFaceColors( cubieColorScheme ) {
			var cubieFaceColors = [ ];
			for (var key in cubieColorScheme) { 	// Each square face is two triangles, so 12 faces to color.
				cubieFaceColors.push( colors[ cubieColorScheme[key] ] );
				cubieFaceColors.push( colors[ cubieColorScheme[key] ] );
			}
			return cubieFaceColors;
		}
		
		function color(geometry, faceColors) {
			for ( var i = 0; i < 12; i ++ ) {    // 12 faces because each square is two triangles.
				geometry.faces[ i ].color.setHex( faceColors[i] );
			}
		}
		
		var geometries = []		// Create a geometry for each cubie so that they can be colored separately.
		for ( let i = 0; i < 27; i++ ) {
			geometries.push( new THREE.BoxGeometry( cubieSize, cubieSize, cubieSize ) );
		}		
		for ( let i = 0; i < 27; i++ ) {    // Color the 27 cubies.
			color(geometries[i], getCubieFaceColors(getCubieColorScheme(keys[i])));
		}			
		
		var material = new THREE.MeshPhongMaterial( {
			//color: 0xffffff,
			side: THREE.DoubleSide,
			vertexColors: THREE.FaceColors,
			polygonOffset: true,
			polygonOffsetFactor: 1, // positive value pushes polygon further away
			polygonOffsetUnits: 1
		} );
		
		
		function addEdges( mesh ) { 	// SOURCE: https://stackoverflow.com/questions/31539130/display-wireframe-and-solid-color
			var geometry = new THREE.EdgesGeometry( mesh.geometry ); // or WireframeGeometry
			var material = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 2 } );
			var edges = new THREE.LineSegments( geometry, material );
			mesh.add( edges );	
		}
		
		var cubies = [];		// Holds 27 cubie meshes.
		
		for (let i = 0; i < 27; i++) {
			cubies.push( new THREE.Mesh( geometries[ i ], material ) );
		}
		
		for (let i = 0; i < 27; i++) {		
			addEdges( cubies[ i ] );    // Add black edges to cubies to make them more distinguishable.
			cubies[ i ].position.set( -1 + i%3 , 1 - Math.floor(i/9), 1 - Math.floor(i/3)%3 );    // Position the cubies left-to-right, front-to-back, top-to-bottom.
			scene.add( cubies[ i ] );    // Add each cubie  to the scene after its edges and position are computed.
			//cubies[i].matrixAutoUpdate = false;
		}
		
		function printObject(object){
			var output = ""
			for (var key in object){
				output = output + key + ": " + object[key] + "\n";
			}
			alert(output);
		}
		function cloneObject(object){
			var output = {};
			for (var key in object){
				output[key] = object[key];
			}
			return output;
		}
		function mapObject(func, object){
			var output = cloneObject(object);
			for (var item in output){
				output[item] = func(output[item]);
			}
			return output;
		}
		
		// ------------------------------------------------------------ End Objects ------------------------------------------------------------
		
		// ------------------------------------------------------------ Start Transformations ------------------------------------------------------------
		
		var orientations = [];
		for (let i = 0; i < 27; i++){
			orientations.push(getCubieColorScheme(keys[i]));	// default color scheme enumerates colors of faces of unrotated cubie
		}

		function computeOrientation(orientation, slice, inverse){
			var clone = cloneObject(orientation);
			var dict = {'R':'FUBD', 'L':'DBUF', 'U':'RFLB', 'D':'BLFR', 'F':'RDLU', 'B':'ULDR', 'M':'FDBU', 'E':'FRBL', 'S':'RDLU', 'X':'UBDF', 'Y':'LBRF', 'Z':'RDLU'};
			var cycle = inverse ? dict[slice].split("").reverse().join("") : dict[slice];    // for example (R not inverse), cycle = 'FUBD'
			var cycled = cycle.substring(3,4) + cycle.substring(0,3);    // then, cycled = 'DFUB'
			var lastColor = clone[cycled[0]];    // store D color
			for (var i = 3; i > 0; i--){    // D gets B color, B gets U color, U gets F color
				clone[cycle[i]] = clone[cycled[i]];
			}
			clone[cycle[0]] = lastColor;    // F gets D color
			return clone;
		}
		function replaceCharacter(word, index, newCharacter){
			word = word.split("");
			word[index] = newCharacter;
			word = word.join("");
			return word;
		}
		function updateKeys(slice, inverse){    // for example, M not inverse
			function swap1(match, p1, p2){
				return p2 + p1;
			}
			function swap2(match, p1, p2, p3){
				return p1 + p3 + p2;
			}
			if ("MESXYZ".indexOf(slice) == -1) return 0;    // escape function if not moving centers
			var dict = {'M':'FDBU', 'E':'FRBL', 'S':'RDLU', 'X':'UBDF', 'Y':'LBRF', 'Z':'RDLU'};
			var cycle = inverse ? dict[slice].split("").reverse().join("") : dict[slice];    // cycle = 'FDBU'
			for (var i = 0; i < 27; i++){    // i = 0:
				let key = keys[i];    // key = "LUF"
				for (var j in key){    // j = 0,  j = 1, j = 2
					let index = cycle.indexOf(key[j]);    // index =  -1, index = 3, index = 0
					if (index !== -1){
						key = replaceCharacter(key, j, cycle[(index + 1)%4]);   // key = LUF, key = LFF, key = LFD
					}
				}
				key = key.replace(/([UDFB]+)([RL])/g, swap1);
				key = key.replace(/([RL])([FB])([UD])/g, swap2);
				keys[i] = key;    // replace key with updated key
			}
		}
		var steps = 20;
		var theta = Math.PI / ( 2 * steps );
		var rotationMatrices = {
			'R':new THREE.Matrix4().makeRotationX( -1*theta ) , 'L':new THREE.Matrix4().makeRotationX( theta ) ,
			'U':new THREE.Matrix4().makeRotationY( -1*theta ) , 'D':new THREE.Matrix4().makeRotationY( theta ) ,
			'F':new THREE.Matrix4().makeRotationZ( -1*theta ) , 'B':new THREE.Matrix4().makeRotationZ( theta ),
			'M':new THREE.Matrix4().makeRotationX( theta ), 'E':new THREE.Matrix4().makeRotationY( theta ),
			'S':new THREE.Matrix4().makeRotationZ( -1*theta ), 'X':new THREE.Matrix4().makeRotationX( -1*theta ),
			'Y':new THREE.Matrix4().makeRotationY( -1*theta ), 'Z':new THREE.Matrix4().makeRotationZ( -1*theta )
		};
		var inverseRotationMatrices = {
			'R':new THREE.Matrix4().makeRotationX( theta ) , 'L':new THREE.Matrix4().makeRotationX( -1*theta ) ,
			'U':new THREE.Matrix4().makeRotationY( theta ) , 'D':new THREE.Matrix4().makeRotationY( -1*theta ) ,
			'F':new THREE.Matrix4().makeRotationZ( theta ) , 'B':new THREE.Matrix4().makeRotationZ( -1*theta ),
			'M':new THREE.Matrix4().makeRotationX( -1*theta ), 'E':new THREE.Matrix4().makeRotationY( -1*theta ),
			'S':new THREE.Matrix4().makeRotationZ( theta ), 'X':new THREE.Matrix4().makeRotationX( theta ),
			'Y':new THREE.Matrix4().makeRotationY( theta ), 'Z':new THREE.Matrix4().makeRotationZ( theta )
		}
		//var allowed = {'value':true};
		function beginSequence(sequence) {
			if (sequence == "") return null;    // Cancel function if no moves left in the sequence
			function multiplier(match, p1, p2){
				var _p1 = p1;
				p2--;
				for(var i = 0; i < p2; i++) {
					p1 += _p1;
				}
				return p1;
			}
			function cleaner(match) {
				return ""
			}
			sequence = sequence.replace(/([RLUDFBMESXYZ])(\d)/g, multiplier);	// if single character is followed by a number
			sequence = sequence.replace(/([(][RLUDFBMESXYZ']+[)])(\d)/g, multiplier);    // if block of characters inside parentheses is followed by a number
			sequence = sequence.replace(/[()]/g, cleaner);    // remove parentheses
			executeSequence(sequence);
		}
		function executeSequence(sequence) {
		//	if (allowed.value) {
			//	allowed.value = false;
			if (sequence == "") return null;    // Cancel function if no moves left in the sequence
			var slice = sequence[0];
			var inverse;
			if (sequence.length > 1 && sequence[1] == "'") {
				inverse = true;
				sequence = sequence.substring(2, sequence.length);
			}
			else {
				inverse = false;
				sequence = sequence.substring(1, sequence.length);
			}
			updateKeys(slice, inverse);
			var step = 0;
			var sliceCubies = [ ]; 
			var dict = {'R':['x',1], 'L':['x',-1], 'U':['y',1], 'D':['y',-1], 'F':['z',1], 'B':['z',-1], 'M':['x',0], 'E':['y',0], 'S':['z',0]}; // Eace slice is determined by the value of the relevant coordinate
			var rotationMatrix = inverse ? inverseRotationMatrices[slice] : rotationMatrices[slice];
			
			if ("XYZ".indexOf(slice) !== -1){
				for (var i = 0; i < 27; i++){
					sliceCubies.push(cubies[i]);
					orientations[i] = computeOrientation(orientations[i], slice, inverse);
				}
			} else{
				for ( var i = 0 ; i < 27 ; i++ ) {		// Get slice
					if ( cubies[ i ].position[ dict[ slice ][0] ] == dict[ slice ][1] ) { // if relevant coordinate of cubie equals corresponding value in dict, extract that cubie.
						sliceCubies.push( cubies[ i ] );
						orientations[i] = computeOrientation(orientations[i], slice, inverse);
					}
				}
			}
			var animate = function( ){
				if (step < steps){ 
					for (var i = 0; i < sliceCubies.length; i++){
						sliceCubies[i].applyMatrix(rotationMatrix);
					}
					step++
					requestAnimationFrame( animate );
				}
				if (step == steps){
					for ( var i = 0 ; i < sliceCubies.length ; i++ ){
						// Clean up matrix
						let elements = sliceCubies[i].matrix.elements;
						for (var j = 0 ; j < 16; j++){
							elements[j] = (Math.round(elements[j]));
						}
						sliceCubies[i].matrix.set(		// Perhaps a more elegant way to set these values?
							elements[0], elements[1], elements[2], elements[3],
							elements[4], elements[5], elements[6], elements[7],
							elements[8], elements[9], elements[10], elements[11],
							elements[12], elements[13], elements[14], elements[15]
						);
						
						// Clean up position
						sliceCubies[ i ].position.x = Math.round(sliceCubies[ i ].position.x);
						sliceCubies[ i ].position.y = Math.round(sliceCubies[ i ].position.y);
						sliceCubies[ i ].position.z = Math.round(sliceCubies[ i ].position.z);
						
						// Clean up quaternion (Doesn't seem to matter, but might as well do it)
						let q = sliceCubies[i].quaternion;    // quaternion
						let c = [q.x, q.y, q.z, q.w];    // components of quaternion
						for (var k = 0; k < 4; k++) {
							if (Math.abs(c[k]) < .001) c[k] = 0;
						}
						q.set(c[0], c[1], c[2], c[3]);
					}	// end for loop
				}	// end if
			};	// end animate definition
			requestAnimationFrame( animate );
			setTimeout(function(){executeSequence(sequence)}, 450);
			//}
		}	// end executeSequence definition

		var tperm = "(RUR'U')(R'F)R2U'R'U'RU(R'F')";
		
		function currentPosition(key){
			var position = cubies[keys.indexOf(key)].position;
			var position = cubies[keys.indexOf(key)].position;
			var keyposition = [];
			x = position.x;
			y = position.y;
			z = position.z;
			if (x == 1) keyposition.push("R");
			if (x == -1) keyposition.push("L");
			if (y == 1) keyposition.push("U");
			if (y == -1) keyposition.push("D");
			if (z == 1) keyposition.push("F");
			if (z == -1) keyposition.push("B");
			return keyposition.join("");
		}
		function correctPosition(key) {
			return (key == currentPosition(key));
			/*
			var correct = new THREE.Vector3();
			for (var i = 0; i < key.length; i++){
				correct.add(cubies[keys.indexOf(key[i])].position);
			}
			return correct.equals(cubies[keys.indexOf(key)].position)
			*/
		}
		function correctOrientation(key){
			var correct = true;
			var orientation = orientations[keys.indexOf(key)];
			for (var i = 0; i < key.length; i++){
				let centerOrientation = orientations[keys.indexOf(key[i])];
				for (var side in centerOrientation){
					if (centerOrientation[side] == 'gray'){
						continue;
					}
					correct = correct && (orientation[side] == centerOrientation[side]);
					break;
				}
			}
			return correct
		}
		function cubieSolved(key){
			return correctOrientation(key);
		}
		function inverse(turn){
			if (turn == "") return turn;
			if (turn.length == 1) return turn + "'";
			if (turn[2] == "'") return turn[1];
			return turn;
		}
		var opposite = {'R':'L', 'L':'R', 'U':'D', 'D':'U', 'F':'B', 'B':'F'};
		var moveSlice = {
			"R":{"U":{"U":"","F":"R'","B":"R","D":"R2"},"F":{"F":"","U":"R","B":"R2","D":"R'"},"B":{"B":"","D":"R","U":"R'","F":"R2"},"D":{"D":"","U":"R2","F":"R","B":"R'"}},
			"L":{"U":{"U":"","F":"L","B":"L'","D":"L2"},"F":{"F":"","U":"L'","B":"L2","D":"L"},"B":{"B":"","D":"L'","U":"L","F":"L2"},"D":{"D":"","U":"L2","F":"L'","B":"L"}},
			"U":{"R":{"R":"","L":"U2","F":"U","B":"U'"},"L":{"R":"U2","L":"","F":"U'","B":"U"},"F":{"R":"U'","L":"U","F":"","B":"U2"},"B":{"R":"U","L":"U'","F":"U2","B":""}},
			"D":{"R":{"R":"","L":"D2","F":"D'","B":"D"},"L":{"R":"D2","L":"","F":"D","B":"D'"},"F":{"R":"D","L":"D'","F":"","B":"D2"},"B":{"R":"D'","L":"D","F":"D2","B":""}},
			"F":{"R":{"R":"","L":"F2","U":"F'","D":"F"},"L":{"L":"","R":"F2","U":"F","D":"F'"},"U":{"U":"","D":"F2","R":"F","L":"F'"},"D":{"D":"","U":"F2","R":"F'","L":"F"}},
			"B":{"R":{"R":"","L":"B2","U":"B","D":"B'"},"L":{"L":"","R":"B2","U":"B'","D":"B"},"U":{"U":"","D":"B2","R":"B'","L":"B"},"D":{"D":"","U":"B2","R":"B","L":"B'"}}
		}

		function beginnerMethod() {
			function matMult(vector, turn){
				clone = vector.clone();
				var angle = Math.PI / 2;
				var rotationMatrices = {	// Used for computing where a piece would be after a given rotation
					'R':new THREE.Matrix4().makeRotationX( -1*angle ) , 'L':new THREE.Matrix4().makeRotationX( angle ) ,
					'U':new THREE.Matrix4().makeRotationY( -1*angle ) , 'D':new THREE.Matrix4().makeRotationY( angle ) ,
					'F':new THREE.Matrix4().makeRotationZ( -1*angle ) , 'B':new THREE.Matrix4().makeRotationZ( angle ),
					"R'":new THREE.Matrix4().makeRotationX( angle ) , "L'":new THREE.Matrix4().makeRotationX( -1*angle ) ,
					"U'":new THREE.Matrix4().makeRotationY( angle ) , "D'":new THREE.Matrix4().makeRotationY( -1*angle ) ,
					"F'":new THREE.Matrix4().makeRotationZ( angle ) , "B'":new THREE.Matrix4().makeRotationZ( -1*angle )
				};
				clone.applyMatrix4(rotationMatrices[turn]);
				clone.x = Math.round(clone.x);
				clone.y = Math.round(clone.y);
				clone.z = Math.round(clone.z);
				return clone
			}
			
			var flEdges = ['DF', 'LD', 'RD', 'DB'];
			var flCorners = ['LDF', 'RDF', 'LDB', 'RDB'];
			var slEdges = ['LF', 'RF', 'LB', 'RB'];
			var tlEdges = ['UF', 'LU', 'RU', 'UB'];
			var tlCorners = ['LUF', 'RUF', 'LUB', 'RUB'];
			var dict = { 'R':['x',1], 'L':['x',-1], 'U':['y',1], 'D':['y',-1], 'F':['z',1], 'B':['z',-1] };
			var opposite = {'R':'L', 'L':'R', 'U':'D', 'D':'U', 'F':'B', 'B':'F'};
			var solution = "";    // this will store the solution to the current step, not necessarily the full solution
			var unsolvedFLE = [];	// unsolved first layer edges

			for (let i = 0; i < 4; i++){
				if (!cubieSolved(flEdges[i])){
					unsolvedFLE.push(flEdges[i]);
				}
			}
			for (var index in unsolvedFLE){    // Solving first layer edges
				let key = unsolvedFLE[index];  // RD
				let position = currentPosition(key);  //RU
				let orientation = orientations[keys.indexOf(key)];
				if (position.indexOf("U") !== -1){    // if cubie is in first layer
					if (orientations[keys.indexOf(key)].U === orientations[keys.indexOf("D")].D){ // if cubie is vertically oriented
						//alert(moveSlice["U"][from][to]);
						let from = (position[0] === "U") ? position[1] : position[0];
						let to = (key[0] === 'D') ? key[1] : key[0];
						solution = solution + moveSlice["U"][from][to] + to + "2";
						// otherSide removed, so no solving yet.
						if (cubies[keys.indexOf(key)].position[dict[otherSide][0]] === dict[otherSide][1]){    // if cubie is positioned directly above correct position
							solution = solution + otherSide + otherSide;
							break;
						}
						if (cubies[keys.indexOf(key)].position[dict[otherSide][0]] === dict[opposite[otherSide]][1]){    // if cubie is positioned opposite correct position
							solution = solution + "U2" + otherSide + otherSide;
							break;
						}
						if (matMult(position, "U")[dict[otherSide][0]] === dict[otherSide][1]){    // if cubie is a U turn from being above correct position
							solution = solution + "U" + otherSide + otherSide;
							break;
						}
						else{    // else, cubie is a U' turn away from being above correct position
							solution = solution + "U'" + otherSide + otherSide;    
							break;
						}
					}
					else{    // else, cubie is not oriented vertically
						//if (to.indexOf("R") !== -1) solution = solution + moveSlice["U"][
						if (matMult(position, "U").z === 1) solution = solution + "U";    
						if (matMult(position, "U'").z === 1) solution = solution + "U'";
						if (matMult(matMult(position, "U"), "U").z === 1) solution = solution + "U2";
						if (otherSide === "R") solution = solution + "D'U'R'FRD";
						if (otherSide === "L") solution = solution + "DU'R'FRD'";
						if (otherSide === "B") solution = solution + "D2U'R'FRD2";
						if (otherSide === "F") solution = solution + "U'R'FR";
						break;
					}
				}
				if (position.indexOf('U') == -1 && position.indexOf('D') == - 1){    // if cubie is in second layer // e.g., key = 'RD' , position = 'RF']]
					if (computeOrientation(orientation, turnSlice[position[0]][position[1]].D, false).D === orientations[keys.indexOf('D')].D) {
					}
				}
			}
			beginSequence(solution);
		}
		
		function handleKeyDown(e){
			if (e.key=='r'||e.key=='l'||e.key=='u'||e.key=='d'||e.key=='f'||e.key=='b'||e.key=='m'||e.key=='e'||e.key=='s'||e.key=='x'||e.key=='y'||e.key=='z'){
				beginSequence(e.key.toUpperCase());
			}
			if (e.key=='R'||e.key=='L'||e.key=='U'||e.key=='D'||e.key=='F'||e.key=='B'||e.key=='M'||e.key=='E'||e.key=='S'||e.key=='X'||e.key=='Y'||e.key=='Z'){
				beginSequence(e.key + "'");
			}	
			if (e.key == 'o'){
				beginnerMethod();
			}
			if (e.key == 'p'){
				beginSequence(tperm);
			}
		}
		window.addEventListener('keydown', handleKeyDown, false);
		
		
	
		// ------------------------------------------------------------ End Transformations ------------------------------------------------------------
		
		//------------------------------------------------------------ Animate ------------------------------------------------------------

		
		// ------------------------------------------------------------ End Animate ------------------------------------------------------------
	</script>
</body>
</html>
