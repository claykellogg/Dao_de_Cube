
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Dao De Cube</title>
	<style>
		body{
			margin: 0px !important;
    		padding: 0px !important;
			overflow: hidden;
		}
	</style>
</head>
<body>
	<script src="three.min.js"></script>
	<script src='OrbitControls.js'></script>
	<script>
		// ------------------------------------------------------------ Scene ------------------------------------------------------------
		var scene = new THREE.Scene( );

		var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 3000 );
		var controls = new THREE.OrbitControls( camera );
		camera.position.set( 0, 8, 12 );
		controls.update( );

		var renderer = new THREE.WebGLRenderer( );
		renderer.setClearColor( 0x000000 );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		window.addEventListener( 'resize', function( ) {
			var width = window.innerWidth;
			var height = window.innerHeight;
			renderer.setSize( width, height );
			camera.aspect = width / height;
			camera.updateProjectionMatrix();
		} );

		var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 1.0 );
		scene.add( ambientLight );

		//var pointLight = new THREE.PointLight( 0xFFFFFF, 0.5 );
		//pointLight.position.set( 0, 20, 20 );
		//scene.add( pointLight );
		
		function render( ) {
			requestAnimationFrame( render );
			renderer.render( scene, camera );
		}
		render( );
		// ------------------------------------------------------------ End Scene ------------------------------------------------------------
		
		// ------------------------------------------------------------ Objects ------------------------------------------------------------
		
		var cubieSize = 1;
		colors = { 
			'white':0xFFFFFF, 'yellow':0xFFFF00, 'red':0xFF0000, 'orange':0xFFA000, 
			'blue':0x0000FF, 'green':0x00FF00, 'gray':0x505050
		};
		colorScheme = { 'R':'red', 'L':'orange', 'U':'yellow', 'D':'white', 'F':'blue', 'B':'green' };
		
		var keys = [
			'LUF', 'UF', 'RUF', 'LU', 'U', 'RU', 'LUB', 'UB', 'RUB',
			'LF', 'F', 'RF', 'L', 'C', 'R', 'LB', 'B', 'RB', 
			'LDF', 'DF', 'RDF', 'LD', 'D', 'RD', 'LDB', 'DB', 'RDB' 
		]
		
		function getCubieColorScheme( key ) {
			var cubieColorScheme = { 'R':'gray', 'L':'gray', 'U':'gray', 'D':'gray', 'F':'gray', 'B':'gray' };  // Default face color is gray until properly computed.
			if ( key == 'C' ) {
				return cubieColorScheme;  // Center cubie is the only default colored cubie.
			}
			for (var index in key ) {
				cubieColorScheme[key[index]] = colorScheme[key[index]];
			}
			return cubieColorScheme;
		}
		
		function getCubieFaceColors( cubieColorScheme ) {
			var cubieFaceColors = [ ];
			for (var key in cubieColorScheme) { 	// Each square face is two triangles, so 12 faces to color.
				cubieFaceColors.push( colors[ cubieColorScheme[key] ] );
				cubieFaceColors.push( colors[ cubieColorScheme[key] ] );
			}
			return cubieFaceColors;
		}
		
		function color(geometry, faceColors) {
			for ( var i = 0; i < 12; i ++ ) {    // 12 faces because each square is two triangles.
				geometry.faces[ i ].color.setHex( faceColors[i] );
			}
		}
		
		var geometries = []		// Create a geometry for each cubie so that they can be colored separately.
		for ( let i = 0; i < 27; i++ ) {
			geometries.push( new THREE.BoxGeometry( cubieSize, cubieSize, cubieSize ) );
		}		
		for ( let i = 0; i < 27; i++ ) {    // Color the 27 cubies.
			color(geometries[i], getCubieFaceColors(getCubieColorScheme(keys[i])));
		}			
		
		var material = new THREE.MeshPhongMaterial( {
			//color: 0xffffff,
			side: THREE.DoubleSide,
			vertexColors: THREE.FaceColors,
			polygonOffset: true,
			polygonOffsetFactor: 1, // positive value pushes polygon further away
			polygonOffsetUnits: 1
		} );
		
		
		function addEdges( mesh ) { 	// SOURCE: https://stackoverflow.com/questions/31539130/display-wireframe-and-solid-color
			var geometry = new THREE.EdgesGeometry( mesh.geometry ); // or WireframeGeometry
			var material = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 2 } );
			var edges = new THREE.LineSegments( geometry, material );
			mesh.add( edges );	
		}
		
		var cubies = [];		// Holds 27 cubie meshes.
		
		for (let i = 0; i < 27; i++) {
			cubies.push( new THREE.Mesh( geometries[ i ], material ) );
		}
		
		for (let i = 0; i < 27; i++) {		
			addEdges( cubies[ i ] );    // Add black edges to cubies to make them more distinguishable.
			cubies[ i ].position.set( -1 + i%3 , 1 - Math.floor(i/9), 1 - Math.floor(i/3)%3 );    // Position the cubies left-to-right, front-to-back, top-to-bottom.
			scene.add( cubies[ i ] );    // Add each cubie  to the scene after its edges and position are computed.
			//cubies[i].matrixAutoUpdate = false;
		}
		
		function printObject(object){
			var output = ""
			for (var key in object){
				output = output + key + ": " + object[key] + "\n";
			}
			alert(output);
		}
		function cloneObject(object){
			var output = {};
			for (var key in object){
				output[key] = object[key];
			}
			return output;
		}
		function mapObject(func, object){
			var output = cloneObject(object);
			for (var item in output){
				output[item] = func(output[item]);
			}
			return output;
		}
		
		function indexOfValue(val, object){
			for (var index in object){
				if (object[index] == val){
					return index;
				}
			}
		}
		
		// ------------------------------------------------------------ End Objects ------------------------------------------------------------
		
		// ------------------------------------------------------------ Start Transformations ------------------------------------------------------------
		
		var orientations = [];
		for (let i = 0; i < 27; i++){
			orientations.push(getCubieColorScheme(keys[i]));	// default color scheme enumerates colors of faces of unrotated cubie
		}

		function computeOrientation(orientation, slice, inverse){
			var clone = cloneObject(orientation);
			var dict = {'R':'FUBD', 'L':'DBUF', 'U':'RFLB', 'D':'BLFR', 'F':'RDLU', 'B':'ULDR', 'M':'FDBU', 'E':'FRBL', 'S':'RDLU', 'X':'FDBU', 'Y':'FRBL', 'Z':'ULDR'};
			var cycle = inverse ? dict[slice].split("").reverse().join("") : dict[slice];    // for example (R not inverse), cycle = 'FUBD'
			var cycled = cycle.substring(3,4) + cycle.substring(0,3);    // then, cycled = 'DFUB'
			var lastColor = clone[cycled[0]];    // store D color
			for (var i = 3; i > 0; i--){    // D gets B color, B gets U color, U gets F color
				clone[cycle[i]] = clone[cycled[i]];
			}
			clone[cycle[0]] = lastColor;    // F gets D color
			return clone;
		}
		function replaceCharacter(word, oldCharacter, newCharacter){
			word = word.split("");
			index = word.indexOf(oldCharacter);
			word.splice(index,1,newCharacter);
			word = word.join("");
			return word;
		}
		
		var keyPermutations = {    // X,Y,Z hardcoded, X',Y',Z' computed from those using Python
			"X":[6,7,8,15,16,17,24,25,26, 3,4,5,12,13,14,21,22,23, 0,1,2,9,10,11,18,19,20],
			"X'":[18,19,20,9,10,11,0,1,2, 21,22,23,12,13,14,3,4,5, 24,25,26,15,16,17,6,7,8],
			"Y":[6,3,0,7,4,1,8,5,2, 15,12,9,16,13,10,17,14,11, 24,21,18,25,22,19,26,23,20],
			"Y'":[2, 5, 8, 1, 4, 7, 0, 3, 6, 11, 14, 17, 10, 13, 16, 9, 12, 15, 20, 23, 26, 19, 22, 25, 18, 21, 24],
			"Z":[2,11,20,5,14,23,8,17,26, 1,10,19,4,13,22,7,16,25, 0,9,18,3,12,21,6,15,24],
			"Z'":[18, 9, 0, 21, 12, 3, 24, 15, 6, 19, 10, 1, 22, 13, 4, 25, 16, 7, 20, 11, 2, 23, 14, 5, 26, 17, 8]
		}
		
		function updateKeys(move, inverse){
			let dict = {'X':'FDBU', 'Y':'FRBL', 'Z':'ULDR'};
			let cycle = inverse ? dict[move].reverse() : dict[move];
			if (inverse) move = move + "'";
			perm = keyPermutations[move];
			newKeys = Array(27).fill("");
			for (let i = 0; i < 27; i++){
				newKeys[i] = keys[perm[i]];
			}
			keys = newKeys;
			let newColorScheme = colorScheme;
			for (let i = 0; i < 4; i++){
				newColorScheme[cycle[i]] = colorScheme[cycle[(i+1)%4]];
			}
			colorScheme = newColorScheme;
		}

		var steps = 20;
		var theta = Math.PI / ( 2 * steps );
		var rotationMatrices = {
			'R':new THREE.Matrix4().makeRotationX( -1*theta ) , 'L':new THREE.Matrix4().makeRotationX( theta ) ,
			'U':new THREE.Matrix4().makeRotationY( -1*theta ) , 'D':new THREE.Matrix4().makeRotationY( theta ) ,
			'F':new THREE.Matrix4().makeRotationZ( -1*theta ) , 'B':new THREE.Matrix4().makeRotationZ( theta ),
			'M':new THREE.Matrix4().makeRotationX( theta ), 'E':new THREE.Matrix4().makeRotationY( theta ),
			'S':new THREE.Matrix4().makeRotationZ( -1*theta ), 'X':new THREE.Matrix4().makeRotationX( -1*theta ),
			'Y':new THREE.Matrix4().makeRotationY( -1*theta ), 'Z':new THREE.Matrix4().makeRotationZ( -1*theta )
		};
		var inverseRotationMatrices = {
			'R':new THREE.Matrix4().makeRotationX( theta ) , 'L':new THREE.Matrix4().makeRotationX( -1*theta ) ,
			'U':new THREE.Matrix4().makeRotationY( theta ) , 'D':new THREE.Matrix4().makeRotationY( -1*theta ) ,
			'F':new THREE.Matrix4().makeRotationZ( theta ) , 'B':new THREE.Matrix4().makeRotationZ( -1*theta ),
			'M':new THREE.Matrix4().makeRotationX( -1*theta ), 'E':new THREE.Matrix4().makeRotationY( -1*theta ),
			'S':new THREE.Matrix4().makeRotationZ( theta ), 'X':new THREE.Matrix4().makeRotationX( theta ),
			'Y':new THREE.Matrix4().makeRotationY( theta ), 'Z':new THREE.Matrix4().makeRotationZ( theta )
		}
		var waitTime = 450;
		//var allowed = {'value':true};
		function beginSequence(sequence) {
			if (sequence == "") return null;    // Cancel function if no moves left in the sequence
			function multiplier(match, p1, p2){
				var _p1 = p1;
				p2--;
				for(var i = 0; i < p2; i++) {
					p1 += _p1;
				}
				return p1;
			}
			function cleaner(match) {
				return ""
			}
			sequence = sequence.replace(/\s+/g, '');
			sequence = sequence.replace(/([RLUDFBMESXYZ])(\d)/g, multiplier);	// if single character is followed by a number
			sequence = sequence.replace(/([(][RLUDFBMESXYZ']+[)])(\d)/g, multiplier);    // if block of characters inside parentheses is followed by a number
			sequence = sequence.replace(/[()]/g, cleaner);    // remove parentheses
			executeSequence(sequence);
		}
		function executeSequence(sequence) {
		//	if (allowed.value) {
			//	allowed.value = false;
			if (sequence == "") return null;    // Cancel function if no moves left in the sequence
			var slice = sequence[0];
			var inverse;
			if (sequence.length > 1 && sequence[1] == "'") {
				inverse = true;
				sequence = sequence.substring(2, sequence.length);
			}
			else {
				inverse = false;
				sequence = sequence.substring(1, sequence.length);
			}
			
			var step = 0;
			var sliceCubies = [ ]; 
			var dict = {'R':['x',1], 'L':['x',-1], 'U':['y',1], 'D':['y',-1], 'F':['z',1], 'B':['z',-1], 'M':['x',0], 'E':['y',0], 'S':['z',0]}; // Eace slice is determined by the value of the relevant coordinate
			var rotationMatrix = inverse ? inverseRotationMatrices[slice] : rotationMatrices[slice];
			
			if ("XYZ".indexOf(slice) !== -1){
				for (var i = 0; i < 27; i++){
					sliceCubies.push(cubies[i]);
				}
				updateKeys(slice,inverse);
			} else{
				for ( var i = 0 ; i < 27 ; i++ ) {		// Get slice
					if ( cubies[ i ].position[ dict[ slice ][0] ] == dict[ slice ][1] ) { // if relevant coordinate of cubie equals corresponding value in dict, extract that cubie.
						sliceCubies.push( cubies[ i ] );
						//orientations[i] = computeOrientation(orientations[i], slice, inverse);
					}
				}
			}
			for (var i = 0; i < sliceCubies.length; i++) {
				let cubieIndex = cubies.indexOf(sliceCubies[i]);
				orientations[cubieIndex] = computeOrientation(orientations[cubieIndex], slice, inverse);
			}
			
			var animate = function( ){
				if (step < steps){ 
					for (var i = 0; i < sliceCubies.length; i++){
						sliceCubies[i].applyMatrix(rotationMatrix);
					}
					step++
					requestAnimationFrame( animate );
				}
				if (step == steps){
					for ( var i = 0 ; i < sliceCubies.length ; i++ ){
						// Clean up matrix
						let elements = sliceCubies[i].matrix.elements;
						for (var j = 0 ; j < 16; j++){
							elements[j] = (Math.round(elements[j]));
						}
						sliceCubies[i].matrix.set(		// Perhaps a more elegant way to set these values?
							elements[0], elements[1], elements[2], elements[3],
							elements[4], elements[5], elements[6], elements[7],
							elements[8], elements[9], elements[10], elements[11],
							elements[12], elements[13], elements[14], elements[15]
						);
						
						// Clean up position
						sliceCubies[ i ].position.x = Math.round(sliceCubies[ i ].position.x);
						sliceCubies[ i ].position.y = Math.round(sliceCubies[ i ].position.y);
						sliceCubies[ i ].position.z = Math.round(sliceCubies[ i ].position.z);
						
						// Clean up quaternion (Doesn't seem to matter, but might as well do it)
						let q = sliceCubies[i].quaternion;    // quaternion
						let c = [q.x, q.y, q.z, q.w];    // components of quaternion
						for (var k = 0; k < 4; k++) {
							if (Math.abs(c[k]) < .001) c[k] = 0;
						}
						q.set(c[0], c[1], c[2], c[3]);
					}	// end for loop
				}	// end if
			};	// end animate definition
			requestAnimationFrame( animate );
			setTimeout(function(){executeSequence(sequence)}, waitTime);
			//}
		}	// end executeSequence definition

		var tperm = "(RUR'U')(R'F)R2U'R'U'RU(R'F')";
		
		function currentPosition(key){
			var position = cubies[keys.indexOf(key)].position;
			var position = cubies[keys.indexOf(key)].position;
			var keyposition = [];
			x = position.x;
			y = position.y;
			z = position.z;
			if (x == 1) keyposition.push("R");
			if (x == -1) keyposition.push("L");
			if (y == 1) keyposition.push("U");
			if (y == -1) keyposition.push("D");
			if (z == 1) keyposition.push("F");
			if (z == -1) keyposition.push("B");
			return keyposition.join("");
		}
		function correctPosition(key) {
			return (key == currentPosition(key));
			/*
			var correct = new THREE.Vector3();
			for (var i = 0; i < key.length; i++){
				correct.add(cubies[keys.indexOf(key[i])].position);
			}
			return correct.equals(cubies[keys.indexOf(key)].position)
			*/
		}
			
		function correctOrientation(key){
			var correct = true;
			var orientation = orientations[keys.indexOf(key)];
			for (var i = 0; i < key.length; i++){
				let centerOrientation = orientations[keys.indexOf(key[i])];
				for (var side in centerOrientation){
					if (centerOrientation[side] == 'gray'){
						continue;
					}
					correct = correct && (orientation[side] == centerOrientation[side]);
					break;
				}
			}
			return correct
		}
		function cubieSolved(key){
			return correctOrientation(key);
		}
		function inverse(turn){
			if (turn == "") return turn;
			if (turn.length == 1) return turn + "'";
			if (turn[1] == "'") return turn[0];
			return turn;
		}
		
		var opposite = {'R':'L', 'L':'R', 'U':'D', 'D':'U', 'F':'B', 'B':'F'};
		var moveSlice = {	// All of this is hardcoded to make my life easy later.
			"R":{"U":{"U":"","F":"R'","B":"R","D":"R2"},"F":{"F":"","U":"R","B":"R2","D":"R'"},"B":{"B":"","D":"R","U":"R'","F":"R2"},"D":{"D":"","U":"R2","F":"R","B":"R'"}},
			"L":{"U":{"U":"","F":"L","B":"L'","D":"L2"},"F":{"F":"","U":"L'","B":"L2","D":"L"},"B":{"B":"","D":"L'","U":"L","F":"L2"},"D":{"D":"","U":"L2","F":"L'","B":"L"}},
			"U":{"R":{"R":"","L":"U2","F":"U","B":"U'"},"L":{"R":"U2","L":"","F":"U'","B":"U"},"F":{"R":"U'","L":"U","F":"","B":"U2"},"B":{"R":"U","L":"U'","F":"U2","B":""}},
			"D":{"R":{"R":"","L":"D2","F":"D'","B":"D"},"L":{"R":"D2","L":"","F":"D","B":"D'"},"F":{"R":"D","L":"D'","F":"","B":"D2"},"B":{"R":"D'","L":"D","F":"D2","B":""}},
			"F":{"R":{"R":"","L":"F2","U":"F'","D":"F"},"L":{"L":"","R":"F2","U":"F","D":"F'"},"U":{"U":"","D":"F2","R":"F","L":"F'"},"D":{"D":"","U":"F2","R":"F'","L":"F"}},
			"B":{"R":{"R":"","L":"B2","U":"B","D":"B'"},"L":{"L":"","R":"B2","U":"B'","D":"B"},"U":{"U":"","D":"B2","R":"B'","L":"B"},"D":{"D":"","U":"B2","R":"B","L":"B'"}}
		}
		function movePiece(slice, from, to){
			// Returns same move info as moveSlice, but can work on positional keys directly
			if (from.length !== to.length) return "";
			from = from.split("");
			to = to.split("");
			from.splice(from.indexOf(slice),1);
			to.splice(to.indexOf(slice),1);
			if (from.length == 1){
				return moveSlice[slice][from[0]][to[0]];
			}else{
				var from1 = from[0];
				var from2 = from[1];
				var to1 = to[0];
				var to2 = to[1];
				return (moveSlice[slice][from1][to1] == moveSlice[slice][from2][to2]) ? moveSlice[slice][from2][to2] : moveSlice[slice][from1][to2];
			}
		}
		var moveCube = {
			"Y":{"R":{"R":"","F":"Y","L":"Y2","B":"Y'"},"L":{"L":"","B":"Y","R":"Y2","F":"Y'"},"F":{"F":"","L":"Y","B":"Y2","R":"Y'"},"B":{"B":"","R":"Y","F":"Y2","L":"Y2"}}
		}
		function doMove(move){
			beginSequence(move);
			if (move.length == 1){
				setTimeout(function(){},waitTime+50);
			}
			if (move.length == 2){
				if (move[1] == "'"){
					setTimeout(function(){},waitTime+50);
				}
				if (move[1] == ["2"]){
					setTimeout(function(){},2*waitTime+50);
				}
			}
		}
		
		var fle = ['DF', 'LD', 'RD', 'DB'];
		var flc = ['LDF', 'RDF', 'LDB', 'RDB'];
		var sle = ['LF', 'RF', 'LB', 'RB'];
		var tle = ['UF', 'LU', 'RU', 'UB'];
		var tlc = ['LUF', 'RUF', 'LUB', 'RUB'];
		var opposite = {'R':'L', 'L':'R', 'U':'D', 'D':'U', 'F':'B', 'B':'F'};
				
		function beginnerMethod(){
			var fleSolved = false;
			var flcSolved= false;
			var sleSolved = false;
			var tleOriented = false;
			var tlcOriented = false;
			var tlcPermuted = false;
			var tlePermuted = false;
			var unsolvedFLE = [];
			var unsolvedFLC = [];

			function pickCubie(){
				for (let i = 0; i < 4; i++){ 
					if (!cubieSolved(fle[i])){
						return fle[i];
					}
				}
				for (let i = 0; i < 4; i++){ 
					if (!cubieSolved(flc[i])){
						return flc[i];
					}
				}
					
			}		
			var solution = "";    // this will store the solution to the current step, not necessarily the full solution
			var key = pickCubie();
			var position = currentPosition(key);
			var orientation = orientations[keys.indexOf(key)];
			if (fle.indexOf(key) !== -1){    // if cubie is fle
				let facing = indexOfValue(colorScheme.D, orientation);
				if (position.indexOf("U") !== -1){    // if cubie is in third layer
					let posMinusU = replaceCharacter(position,"U","");
					alert(moveCube["Y"][posMinusU]["F"]);
					doMove(moveCube["Y"][posMinusU]["F"]);
					position = currentPosition(key);
					orientation = orientations[keys.indexOf(key)];
					doMove(movePiece("U",position,"LU"));
					position = currentPosition(key);
					orientation = orientations[keys.indexOf(key)];
					if (facing == "U"){
						doMove("F2");
					}
				}
				if (position.indexOf('U') == -1 && position.indexOf('D') == - 1){    // if cubie is in second layer
					let slice = (position[0] == facing) ? position[1] : position[0];
					let to = (key[0] === 'D') ? key[1] : key[0];
					solution = solution + moveSlice["D"][to][slice] + moveSlice[slice][facing]["D"] + moveSlice["D"][slice][to];
				}
				if (position.indexOf("D") !== -1){    // if cubie is in first layer
					let from = (position[0] === "D") ? position[1] : position[0]; // Which vertical face is the cubie in?
					let to = (key[0] === 'D') ? key[1] : key[0];    // Which vertical face does the cubie belong in?
					let slice = (from == "R") ? "F" : "FLBR"["FLBR".indexOf(from) + 1];
					if (facing == "U"){    // If cubie is vertically oriented
						solution = solution + from + moveSlice["D"][to][from] + from + "'" + moveSlice["D"][from][to];
					}else{
						solution = solution + from + moveSlice["D"][to][slice] + moveSlice[slice][from]["D"] + moveSlice["D"][slice][to];
					}
				}
			}
			if (flc.indexOf(key) !== -1){    // if cubie is flc
				let facing = indexOfValue(colorScheme.D, orientation);
				if (position.indexOf("U") !== -1){    // if cubie is in third layer
					above = replaceCharacter(key,"D","U"); //RUF
					solution = solution + movePiece("U",position,above);
					if (solution.length == 1){
						orientation = computeOrientation(orientation,"U",false);
					}
					if (solution.length == 2){
						orientation = (solution[1] == "'") ? computeOrientation(orientation,"U",true) : computeOrientation(computeOrientation(orientation,"U",false),"U",false);
					}
					facing = indexOfValue(colorScheme.D, orientation);
					let minusU = replaceCharacter(above,"U",""); //RF
					if (facing == "U"){    // if vertically oriented
						let side1 = minusU[0]; //R
						let side2 = minusU[1]; //F
						let intermediate1 = replaceCharacter(replaceCharacter(above,above[0],opposite[above[0]]),above[2],opposite[above[2]]);
						let intermediate2 = replaceCharacter(above,side2,opposite[side2]);
						let m1 = moveSlice[side1][side2]["U"]; //R
						let m2 = movePiece("U",intermediate1,intermediate2); //U
						let m3 = inverse(m1); //R'
						solution = solution + "U2" + m1 + m2 + m3 + m2 + m1 + inverse(m2) + m3;
						
					}else{
						to = minusU[minusU.indexOf(facing)]; //F
						from = minusU[1-minusU.indexOf(facing)]; //R
						let m1 = moveSlice["U"][from][to]; //U
						let m2 = moveSlice[from][facing]["U"]; //R
						let m3 = moveSlice["U"][to][from]; //U'
						let m4 = moveSlice[from]["U"][facing]; //R'
						solution = solution + m1 + m2 + m3 + m4;
					}
				}else{ //cubie is in first layer
					let m1 = moveSlice[position[0]][position[2]]["U"];
					solution = solution + m1 + "U2" + inverse(m1);
				}
			}
			beginSequence(solution);
		}
		
		function handleKeyDown(e){
			if (e.key=='r'||e.key=='l'||e.key=='u'||e.key=='d'||e.key=='f'||e.key=='b'||e.key=='m'||e.key=='e'||e.key=='s'||e.key=='x'||e.key=='y'||e.key=='z'){
				beginSequence(e.key.toUpperCase());
			}
			if (e.key=='R'||e.key=='L'||e.key=='U'||e.key=='D'||e.key=='F'||e.key=='B'||e.key=='M'||e.key=='E'||e.key=='S'||e.key=='X'||e.key=='Y'||e.key=='Z'){
				beginSequence(e.key + "'");
			}	
			if (e.key == 'o'){
				alert(currentPosition("RUF"));
				printObject(orientations[keys.indexOf("LD")]);
			}
			if (e.key == 'p'){
				beginSequence("B  U'  F  R2  L'  U2  F'  D  F'  R  B2  F2  U'  R'  B2  U2  F  R  L  F  L'  D  U2  F  D2");
			}
			if (e.key == 'k'){
				beginnerMethod();
			}
			
		}
		window.addEventListener('keydown', handleKeyDown, false);
		
		
	
		// ------------------------------------------------------------ End Transformations ------------------------------------------------------------
		
		//------------------------------------------------------------ Animate ------------------------------------------------------------

		
		// ------------------------------------------------------------ End Animate ------------------------------------------------------------
	</script>
</body>
</html>
